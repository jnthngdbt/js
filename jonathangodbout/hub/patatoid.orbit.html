<!DOCTYPE html>
<html>
<head>
    <title>JNTHNGDBT - Patatoid orbit</title>

    <meta charset="UTF-8">
    <meta name="author" content="jnthngdbt">
    <meta name="keywords" content="jnthngdbt">

    <!-- Together with [...text-size-adjust] in CSS, avoids font rescaling when switching orientation -->
    <meta name="viewport" content="width=device-width, initial-scale=1"> 

	<style>
		body {
			margin: 0px;
		}
	</style>
</head>

<body>
	<!-- THREE.js stuff (3D and controls) -->
	<script src="../js/three.js/build/three.min.js"></script>
	<script src="../js/three.js/examples/js/controls/TrackballControls.js"></script>

	<!-- Custom stuff -->
	<script type="text/javascript" src="../js/path.navigation.controls.js"></script>

	<!-- Main script -->
	<script type="text/javascript">

	"use strict";

	// SCENE

    var scene = new THREE.Scene();

    // CAMERA

	var aspect = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera( 30, aspect, 1, 500000 );
    scene.add(camera);

	// OBJECT - PATATOID

	var patatoid = {};

	patatoid.radius = 20000;
	patatoid.deformFactor = 0.06;

	patatoid.geometry = new THREE.DodecahedronGeometry(
		patatoid.radius, 2);
	patatoid.material = new THREE.MeshPhongMaterial( { 
		color: 0x888888, 
		shading: THREE.FlatShading } );
    patatoid.mesh = new THREE.Mesh( patatoid.geometry, patatoid.material );

    var v = patatoid.geometry.vertices;
    for (var i = 0; i < v.length; i++){
    	var deform = patatoid.deformFactor * Math.random() * patatoid.radius;
    	v[i].x += Math.random() > 0.5 ? 10*deform : -10*deform;
    	v[i].y += Math.random() > 0.5 ? deform : -deform;
    	v[i].z += Math.random() > 0.5 ? deform : -deform;
    }
	patatoid.geometry.verticesNeedUpdate

    scene.add( patatoid.mesh );

	// PATH

	var campath = {};

	campath.radius = patatoid.radius * 6.0;
	campath.circum = 2.0 * Math.PI * campath.radius;
	campath.minRadius = patatoid.radius * 1.3;

	campath.curve = new THREE.EllipseCurve( // 2D
		0,  0,            		// ax, aY
		campath.radius, campath.radius,	// xRadius, yRadius
		0,  2 * Math.PI,  		// aStartAngle, aEndAngle
		false,            		// aClockwise
		0);               		// aRotation

	campath.center = new THREE.Vector3(0, 0, campath.radius-campath.minRadius)
	campath.path = new THREE.Path( campath.curve.getPoints( 500 ) ); // 2D

	campath.position = new THREE.Vector3(0.0, 0.0, campath.center.z);
	campath.rotation = new THREE.Vector3(Math.PI/2, 0.0, 0.0);

	campath.geometry = campath.path.createPointsGeometry( 500 ); // 3D
	campath.material = new THREE.LineDashedMaterial( {
		color: 0xcccccc,
		linewidth: 5,
		scale: 1,
		dashSize: 0.1,
		gapSize: 100,
	} );

	campath.object = new THREE.Line( campath.geometry, campath.material );
	// campath.object.rotation.x = Math.PI/2;
	// campath.object.position.z = campath.center.z;

	//scene.add(campath.object);

    // LIGHT

	var intensity = 1;
	var decay = 2;

	var lights = [];

	lights.push( new THREE.PointLight(0x66ff66, intensity, 0, decay) );
	lights[0].position.x = 50000;
	lights[0].position.y = 50000;
	lights[0].position.z = -50000;

	scene.add( lights[0] );

	lights.push( new THREE.PointLight(0xffaa66, intensity, 0, decay)) ;
	lights[1].position.x = -50000;
	lights[1].position.y = -50000;
	lights[1].position.z = -50000;

	scene.add( lights[1] );

	scene.add( new THREE.AmbientLight(0xbbbbbb) );

    // RENDERER

    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor(0xefefef)

	// CONTROLS

	// var controls = new THREE.TrackballControls( camera );
	// controls.rotateSpeed = 1.0;
	// controls.zoomSpeed = 0.2;
	// controls.noPan = true;
	// controls.minDistance = patatoid.radius * (patatoid.deformFactor + 1);
	// controls.maxDistance = 1000000;
 //    controls.addEventListener( 'change', render );
 //    camera.position.z = 10*patatoid.radius;

	camera.position.y = 100000;
	var controls = new PathNavigationControls(camera, campath.path, campath.position, campath.rotation);
	controls.acceleration = 0.00001; //8.0;
	controls.isClosedPath = true;
	//camera.position.z = 100000; // TBM

	//

    document.body.appendChild( renderer.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

    animate();

    //

	function animate() {

	    requestAnimationFrame( animate );

	    controls.update();

	    // //// Deal with camera path from the controls.
	    // var angle = controls.displacement/campath.circum * 2*Math.PI;
	    // camera.position.x = campath.radius * Math.sin(angle);
	    // camera.position.z = campath.radius * Math.cos(angle) + (campath.radius-campath.minRadius);
	    camera.lookAt(new THREE.Vector3(0,123,-patatoid.radius));

	    ////// camera.rotateY(0.00001 * Math.PI * controls.lookX);	
		////// camera.rotation.x = -Math.PI/10.0;
		//////camera.rotation.y = angle - 0.8*Math.PI/2.0;

		// Slowly rotate the patatoid.
	    //patatoid.mesh.rotation.x += 0.0005;
	    patatoid.mesh.rotation.y += 0.0005;

	    render();
	}

	function render() {
		renderer.render(scene, camera);
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
		// controls.handleResize();
	}

	</script>

</body>
</html>